## 挿入ソート
### Original
```
void mysort(int A[], int digits) {
  int n = 0;
  for (int i = 0; i < digits; i ++) {
    for (int n = 0; n < digits; n++) {
      if (n + 1 == digits) break;
      if (A[n] > A[n + 1]) {
        int before = A[n + 1];
        int after = A[n];
        A[n] = before;
        A[n + 1] = after;
      }
    }
    trace(A, digits);
    n = 0;
  }
}
```

サンプルの挿入ソートとは多少異なるアルゴリズムになっている。(こちらのほうが遅い）

> 考え方(処理実行例)

左から順番に全てを評価(一つ後にある値（n+1)と大きさを比較)し、大きい場合入れ替えをしていく。

```
5 4 3 2 1
1周目の1周目 5 > 4 => true => 4 5 3 2 1
1周目の2周目 5 > 3 => true => 4 3 5 2 1
1周目の3周目 5 > 2 => true => 4 3 2 5 1
1周目の4周目 5 > 2 => true => 4 3 2 1 5
1周目の5周目 break => true =>
2周目の1周目 4 > 3 => true => 3 4 2 1 5
...
```
これを配列の要素数分繰り返すアルゴリズム。

### Sample
0番目の値を操作済みとし、操作済みの値を除いた一番左の値を前の値と比較し小さければ入れ替える
0番目と1番目の値を操作済みとし、操作済みの値を除い一番左の値*を前の値と比較し小さければ入れ替える評価対象より小さいものがあるまで繰り返す
0, 1, 2番目の値を操作済みとし、操作済みの値を除い一番左の値*を前の値と比較し小さければ入れ替える評価対象より小さいものがあるまで繰り返す
上記にならって要素数分繰り返す。

```
void sample_sort(int A[], int N) {
  int j, i, v;
  for ( i = 1; i < N; i++ ) { // 未操作要素を繰り返す。0番目の値は初めから操作済みとするためi = 1となる
    v = A[i]; 操作対象の値（操作済みの値を除いた一番左の値）
    j = i - 1; // 隣り合う要素のインデックス
    while ( j >= 0 && A[j] > v ) {
      A[j + 1] = A[j];
      j--; // 隣り合う要素のインデックスを更新
    }
    A[j + 1] = v;
    trace(A, N);
  }
}
```

